/**
 * Matrix Factorization to estimate
 * the possible combination of user-item rating matrix
 *
 * @author      Kwangil Cho
 * @since       2017-06-05
 * @file        matrixfact.cc
 */
#include "recommender.h" 
#include "user.h" 
#include "item.h" 
#include <vector>
#include <ctime>
#include <cstdlib>
#include <cmath>

#define NUM_ITERATION  5000

/* latent value */
const int K = 2;
/* 2D user-rating matrix */
vector<vector<double>> P;
/* 2D item-rating matrix */
vector<vector<double>> Q;

/**
 * Calculate the matrix P x Q multiplied value
 * @param[in]   index i index of P[i] row
 *              index j index of Q[j] column
 *
 * @return      matrix multiplied value
 */
double MultiplyMatrix(int i, int j) {
    double sum = 0;
    for (int k = 1; k <= K; k++) {
        sum += P[i][k] * Q[k][j];
    }
    return sum;
}

/**
 * Initialize the base matrices P and Q with
 * Randomized value between 0.00001 ~ 5.00000
 *
 * P: NUM_USER X K matrix
 * Q: K X NUM_ITEM matrix
 */
void InitBaseMatrix() {
    vector<double> tmp;
    double rnd = 0;
    for (int i = 0; i <= NUM_USER; i++) {
        tmp.clear();
        for (int j = 0; j <= K; j++) {
            rnd = (double)(rand() % 500000 + 1) / (double)(100000);
            tmp.push_back(rnd); 
        }
        P.push_back(tmp);
    }

    for (int i = 0; i <= K; i++) {
        tmp.clear();
        for (int j = 0; j <= NUM_ITEM; j++) {
            rnd = (double)(rand() % 500000 + 1) / (double)(100000);
            tmp.push_back(rnd); 
        }
        Q.push_back(tmp);
    }
}

/**
 * Factorize the original matrix into two base matrices
 *
 * R: NUM_USER X NUM_ITEM matrix
 * P: NUM_USER X K matrix
 * Q: K X NUM_ITEM matrix
 * R': New P X Q matrix which is newly generated by FM
 */
void FactorizeMatrix() {
    double alpha = 0.0002; // determines the rate of approaching the minimum
    double beta = 0.02; // controls the magnitudes of the user-feature and item-feature vectors
    double **R = g_rating_matrix; // original rating matrix
    double eij = 0; // difference between original and new element
    // double error = 0;

    srand(time(NULL));
    InitBaseMatrix();

    for (int repeat = 0; repeat < NUM_ITERATION; repeat++) {
        for (int i = 1; i <= NUM_USER; i++) {
            for (int j = 1; j <= NUM_ITEM; j++) {
                if(R[i][j] > 0) {
                    eij = R[i][j] - MultiplyMatrix(i, j);
                    /* finding the optimized value of each element in P and Q 
                     * fix the value slowly to fit the original value */
                    for (int k = 1; k <= K; k++) {
                        P[i][k] = P[i][k] + alpha * (2 * eij * Q[k][j] - beta * P[i][k]);
                        Q[k][j] = Q[k][j] + alpha * (2 * eij * P[i][k] - beta * Q[k][j]);
                    }
                }
            }
        }

        /* For checking the difference between origianl R and new R
         * error = 0;
         * for (int i = 1; i <= NUM_USER; i++) {
         *     for (int j = 1; j <= NUM_ITEM; j++) {
         *         if(R[i][j] > 0) {
         *             error = error + pow(R[i][j] - MultiplyMatrix(i, j), 2);
         *             for (int k = 1; k <= K; k++) {
         *                 error = error + (beta / 2) * (pow(P[i][k] , 2) + pow(Q[k][j], 2));
         *             }
         *         }
         *     }
         * }
         */
    }

    for (int i = 1; i <= NUM_USER; i++) {
        for (int j = 1; j <= NUM_ITEM; j++) {
            R[i][j] = MultiplyMatrix(i, j);
            /* handle over/underflow case */
            R[i][j] = R[i][j] > 5 ? 5 : R[i][j];
            R[i][j] = R[i][j] < 1 ? 1 : R[i][j];
        }
    }
}
